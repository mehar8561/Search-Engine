OWL Web Ontology Language Mapping RDF Graphs Edition) OWL Web Ontology Language Mapping RDF Graphs Edition) W3C Recommendation December version: Latest version Latest Recommendation: Previous version: Editors: Peter F. Patel-Schneider, Nuance Communications Boris Motik, University Oxford Contributors: alphabetical order) Bernardo Cuenca Grau, University Oxford Ian Horrocks, University Oxford Bijan Parsia, University Manchester Alan Ruttenberg, Science Commons Commons) Michael Schneider, FZI Research Center Information Technology refer errata document, include normative corrections. color-coded version document showing changes made since previous version also available. document also available non-normative formats: PDF version. also translations. Copyright W3CÂ® ERCIM, Keio), Rights Reserved. W3C liability, trademark document use rules apply. Abstract OWL Web Ontology Language, informally OWL ontology language Semantic Web formally defined meaning. OWL ontologies provide classes, properties, individuals, data values are stored as Semantic Web documents. OWL ontologies be used along information written RDF, OWL ontologies are primarily exchanged as RDF documents. OWL Document Overview overall state OWL be read before other OWL documents. document mapping OWL ontologies RDF graphs, vice versa. Status Document May Be Superseded section status document time publication. Other documents supersede document. list current W3C publications latest revision technical report be found W3C technical reports index Summary Changes There have been substantive changes since previous version. details minor changes change log color-coded diff. Send Comments send comments archive). work document OWL Working Group complete, comments be addressed errata future revisions. Open discussion developers archive). Endorsed W3C document been reviewed W3C Members, software developers, other W3C groups interested parties, endorsed Director as W3C Recommendation. stable document be used as reference material cited document. W3C's role making Recommendation draw attention specification promote widespread deployment. functionality interoperability Web. Patents document was produced group operating February W3C Patent Policy. W3C public list patent disclosures made connection deliverables group; page also instructions disclosing patent. Table Contents Introduction Preliminaries Mapping Structural Specification RDF Graphs Translation Axioms Annotations Translation Annotations Translation Axioms Annotations Axioms Generate Main Triple Axioms are Translated Multiple Triples Axioms Represented Blank Nodes Mapping RDF Graphs Structural Specification Extracting Declarations IRIs Directly Imported Ontology Documents Resolving Included RDF Graphs Parsing Ontology Header Declarations Populating Ontology Analyzing Declarations Parsing Annotations Parsing Ontology Annotations Parsing Expressions Parsing Axioms Appendix: Change Log Changes Recommendation Changes Proposed Recommendation Changes Candidate Recommendation Changes Last Call Acknowledgments References Introduction Preliminaries document mappings structural specification OWL Specification] RDF graphs Concepts]. mapping presented Section be used transform OWL ontology RDF graph T(O). mapping presented Section be used transform RDF graph G satisfying certain restrictions OWL DL ontology OG. transformations do not incur change formal meaning ontology. More precisely, OWL DL ontology let G T(O) be RDF graph obtained transforming as specified Section let OG be OWL DL ontology obtained applying reverse transformation Section G; then, OG are logically equivalent have exactly same set models. mappings presented document are backwards-compatible OWL DL: OWL DL ontology encoded as RDF graph be mapped valid OWL DL ontology using mapping Section such resulting OWL DL ontology exactly same set models as original OWL DL ontology. syntax triples used document used RDF Semantics Semantics]. Full IRIs are abbreviated using prefixes OWL Specification Specification]. OWL ontologies mentioned document be understood as instances structural specification OWL Specification]; required, are written document using functional-style syntax. following notation used document referring parts RDF graphs: IRI; blank node; blank node IRI; lt literal; xlt blank node, IRI, literal. italicized keywords NOT, NOT, MAY are used specify normative features OWL documents tools, are interpreted as specified RFC Mapping Structural Specification RDF Graphs section mapping OWL ontology RDF graph T(O). mapping presented parts. Section shows translate axioms do not contain annotations, Section shows translate annotations, Section shows translate axioms containing annotations. Translation Axioms Annotations Table presents operator T maps OWL ontology RDF graph T(O), provided axiom annotated. mapping defined recursively; mapping construct often mappings subconstructs, slightly unusual way: mapping construct mapping subconstruct, then triples generated recursive invocation mapping subconstruct are added graph construction, main node mapping subconstruct used place recursive invocation definition operator T uses operator TANN order translate annotations. operator TANN defined Section annotation IRI blank node triples attach annotation supplied object. mapping, generated blank node blank node not correspond anonymous individual) fresh application mapping rule. Furthermore, possible conditions mapping rules are enclosed curly braces Finally, following conventions are used section denote different parts OWL ontologies: OP object property; OPE object property expression; DP data property; DPE data property expression; AP annotation property; C class; CE class expression; DT datatype; DR data range; U IRI; F constraining facet; individual anonymous); named individual; lt literal; as annotation source; av annotation value. section, T(SEQ y1 yn) translation sequence objects structural specification RDF list, as shown Table Table Transformation Triples Element E Structural Specification Triples Generated Invocation T(E) Main Node T(E) SEQ rdf:nil SEQ y1 yn rdf:first T(y1) rdf:rest T(SEQ y2 yn) Ontology( ontologyIRI versionIRI Import( importedOntologyIRI1 Import( importedOntologyIRIk annotation1 annotationm axiom1 axiomn ontologyIRI rdf:type owl:Ontology ontologyIRI owl:versionIRI versionIRI ontologyIRI owl:imports importedOntologyIRI1 ontologyIRI owl:imports importedOntologyIRIk TANN(annotation1, ontologyIRI) TANN(annotationm, ontologyIRI) T(axiom1) T(axiomn) ontologyIRI Ontology( Import( importedOntologyIRI1 Import( importedOntologyIRIk annotation1 annotationm axiom1 axiomn rdf:type owl:Ontology owl:imports importedOntologyIRI1 owl:imports importedOntologyIRIk TANN(annotation1, TANN(annotationm, T(axiom1) T(axiomn) C C DT DT OP OP DP DP AP AP U U lt lt literal datatype other rdf:PlainLiteral lt Declaration( Datatype( DT T(DT) rdf:type rdfs:Datatype Declaration( Class( C T(C) rdf:type owl:Class Declaration( ObjectProperty( OP T(OP) rdf:type owl:ObjectProperty Declaration( DataProperty( DP T(DP) rdf:type owl:DatatypeProperty Declaration( AnnotationProperty( AP T(AP) rdf:type owl:AnnotationProperty Declaration( NamedIndividual( T(*:a) rdf:type owl:NamedIndividual ObjectInverseOf( OP owl:inverseOf T(OP) DataIntersectionOf( DR1 DRn rdf:type rdfs:Datatype owl:intersectionOf T(SEQ DR1 DRn) DataUnionOf( DR1 DRn rdf:type rdfs:Datatype owl:unionOf T(SEQ DR1 DRn) DataComplementOf( DR rdf:type rdfs:Datatype owl:datatypeComplementOf T(DR) DataOneOf( lt1 ltn rdf:type rdfs:Datatype owl:oneOf T(SEQ lt1 ltn) DatatypeRestriction( DT F1 lt1 Fn ltn rdf:type rdfs:Datatype owl:onDatatype T(DT) owl:withRestrictions T(SEQ F1 lt1 Fn ltn ObjectIntersectionOf( CE1 CEn rdf:type owl:Class owl:intersectionOf T(SEQ CE1 CEn) ObjectUnionOf( CE1 CEn rdf:type owl:Class owl:unionOf T(SEQ CE1 CEn) ObjectComplementOf( CE rdf:type owl:Class owl:complementOf T(CE) ObjectOneOf( a1 rdf:type owl:Class owl:oneOf T(SEQ a1 ObjectSomeValuesFrom( OPE CE rdf:type owl:Restriction owl:onProperty T(OPE) owl:someValuesFrom T(CE) ObjectAllValuesFrom( OPE CE rdf:type owl:Restriction owl:onProperty T(OPE) owl:allValuesFrom T(CE) ObjectHasValue( OPE rdf:type owl:Restriction owl:onProperty T(OPE) owl:hasValue T(a) ObjectHasSelf( OPE rdf:type owl:Restriction owl:onProperty T(OPE) owl:hasSelf ObjectMinCardinality( n OPE rdf:type owl:Restriction owl:onProperty T(OPE) owl:minCardinality ObjectMinCardinality( n OPE CE rdf:type owl:Restriction owl:onProperty T(OPE) owl:minQualifiedCardinality owl:onClass T(CE) ObjectMaxCardinality( n OPE rdf:type owl:Restriction owl:onProperty T(OPE) owl:maxCardinality ObjectMaxCardinality( n OPE CE rdf:type owl:Restriction owl:onProperty T(OPE) owl:maxQualifiedCardinality owl:onClass T(CE) ObjectExactCardinality( n OPE rdf:type owl:Restriction owl:onProperty T(OPE) owl:cardinality ObjectExactCardinality( n OPE CE rdf:type owl:Restriction owl:onProperty T(OPE) owl:qualifiedCardinality owl:onClass T(CE) DataSomeValuesFrom( DPE DR rdf:type owl:Restriction owl:onProperty T(DPE) owl:someValuesFrom T(DR) DataSomeValuesFrom( DPE1 DPEn DR n rdf:type owl:Restriction owl:onProperties T(SEQ DPE1 DPEn) owl:someValuesFrom T(DR) DataAllValuesFrom( DPE DR rdf:type owl:Restriction owl:onProperty T(DPE) owl:allValuesFrom T(DR) DataAllValuesFrom( DPE1 DPEn DR n rdf:type owl:Restriction owl:onProperties T(SEQ DPE1 DPEn) owl:allValuesFrom T(DR) DataHasValue( DPE lt rdf:type owl:Restriction owl:onProperty T(DPE) owl:hasValue T(lt) DataMinCardinality( n DPE rdf:type owl:Restriction owl:onProperty T(DPE) owl:minCardinality DataMinCardinality( n DPE DR rdf:type owl:Restriction owl:onProperty T(DPE) owl:minQualifiedCardinality owl:onDataRange T(DR) DataMaxCardinality( n DPE rdf:type owl:Restriction owl:onProperty T(DPE) owl:maxCardinality DataMaxCardinality( n DPE DR rdf:type owl:Restriction owl:onProperty T(DPE) owl:maxQualifiedCardinality owl:onDataRange T(DR) DataExactCardinality( n DPE rdf:type owl:Restriction owl:onProperty T(DPE) owl:cardinality DataExactCardinality( n DPE DR rdf:type owl:Restriction owl:onProperty T(DPE) owl:qualifiedCardinality owl:onDataRange T(DR) SubClassOf( CE1 CE2 T(CE1) rdfs:subClassOf T(CE2) EquivalentClasses( CE1 CEn T(CE1) owl:equivalentClass T(CE2) T(CEn-1) owl:equivalentClass T(CEn) DisjointClasses( CE1 CE2 T(CE1) owl:disjointWith T(CE2) DisjointClasses( CE1 CEn n rdf:type owl:AllDisjointClasses owl:members T(SEQ CE1 CEn) DisjointUnion( C CE1 CEn T(C) owl:disjointUnionOf T(SEQ CE1 CEn) SubObjectPropertyOf( OPE1 OPE2 T(OPE1) rdfs:subPropertyOf T(OPE2) SubObjectPropertyOf( ObjectPropertyChain( OPE1 OPEn OPE T(OPE) owl:propertyChainAxiom T(SEQ OPE1 OPEn) EquivalentObjectProperties( OPE1 OPEn T(OPE1) owl:equivalentProperty T(OPE2) T(OPEn-1) owl:equivalentProperty T(OPEn) DisjointObjectProperties( OPE1 OPE2 T(OPE1) owl:propertyDisjointWith T(OPE2) DisjointObjectProperties( OPE1 OPEn n rdf:type owl:AllDisjointProperties owl:members T(SEQ OPE1 OPEn) ObjectPropertyDomain( OPE CE T(OPE) rdfs:domain T(CE) ObjectPropertyRange( OPE CE T(OPE) rdfs:range T(CE) InverseObjectProperties( OPE1 OPE2 T(OPE1) owl:inverseOf T(OPE2) FunctionalObjectProperty( OPE T(OPE) rdf:type owl:FunctionalProperty InverseFunctionalObjectProperty( OPE T(OPE) rdf:type owl:InverseFunctionalProperty ReflexiveObjectProperty( OPE T(OPE) rdf:type owl:ReflexiveProperty IrreflexiveObjectProperty( OPE T(OPE) rdf:type owl:IrreflexiveProperty SymmetricObjectProperty( OPE T(OPE) rdf:type owl:SymmetricProperty AsymmetricObjectProperty( OPE T(OPE) rdf:type owl:AsymmetricProperty TransitiveObjectProperty( OPE T(OPE) rdf:type owl:TransitiveProperty SubDataPropertyOf( DPE1 DPE2 T(DPE1) rdfs:subPropertyOf T(DPE2) EquivalentDataProperties( DPE1 DPEn T(DPE1) owl:equivalentProperty T(DPE2) T(DPEn-1) owl:equivalentProperty T(DPEn) DisjointDataProperties( DPE1 DPE2 T(DPE1) owl:propertyDisjointWith T(DPE2) DisjointDataProperties( DPE1 DPEn n rdf:type owl:AllDisjointProperties owl:members T(SEQ DPE1 DPEn) DataPropertyDomain( DPE CE T(DPE) rdfs:domain T(CE) DataPropertyRange( DPE DR T(DPE) rdfs:range T(DR) FunctionalDataProperty( DPE T(DPE) rdf:type owl:FunctionalProperty DatatypeDefinition( DT DR T(DT) owl:equivalentClass T(DR) HasKey( CE OPE1 OPEm DPE1 DPEn T(CE) owl:hasKey T(SEQ OPE1 OPEm DPE1 DPEn SameIndividual( a1 T(a1) owl:sameAs T(a2) T(an-1) owl:sameAs T(an) DifferentIndividuals( a1 a2 T(a1) owl:differentFrom T(a2) DifferentIndividuals( a1 n rdf:type owl:AllDifferent owl:members T(SEQ a1 ClassAssertion( CE T(a) rdf:type T(CE) ObjectPropertyAssertion( OP a1 a2 T(a1) T(OP) T(a2) ObjectPropertyAssertion( ObjectInverseOf( OP a1 a2 T(a2) T(OP) T(a1) NegativeObjectPropertyAssertion( OPE a1 a2 rdf:type owl:NegativePropertyAssertion owl:sourceIndividual T(a1) owl:assertionProperty T(OPE) owl:targetIndividual T(a2) DataPropertyAssertion( DPE lt T(a) T(DPE) T(lt) NegativeDataPropertyAssertion( DPE lt rdf:type owl:NegativePropertyAssertion owl:sourceIndividual T(a) owl:assertionProperty T(DPE) owl:targetValue T(lt) AnnotationAssertion( AP as av T(as) T(AP) T(av) SubAnnotationPropertyOf( AP1 AP2 T(AP1) rdfs:subPropertyOf T(AP2) AnnotationPropertyDomain( AP U T(AP) rdfs:domain T(U) AnnotationPropertyRange( AP U T(AP) rdfs:range T(U) Translation Annotations operator TANN, annotations IRI blank node, defined Table Table Translation Annotations Annotation ann Triples Generated Invocation TANN(ann, y) Annotation( AP av T(y) T(AP) T(av) Annotation( annotation1 annotationn AP av T(y) T(AP) T(av) rdf:type owl:Annotation owl:annotatedSource T(y) owl:annotatedProperty T(AP) owl:annotatedTarget T(av) TANN(annotation1, TANN(annotationn, Let ann be following annotation. Annotation( rdfs:label Griffin" invocation TANN(ann, then following triples. rdfs:label Griffin" Let ann be following annotation, annotated. Annotation( Annotation( rdfs:label Griffin" invocation TANN(ann, then following triples: rdfs:label Griffin" rdf:type owl:Annotation owl:annotatedSource owl:annotatedProperty rdfs:label owl:annotatedTarget Griffin" Translation Axioms Annotations axiom ax embedded annotations annotation1 annotationm, serialization RDF type axiom. Let ax' be axiom obtained ax removing axiom annotations. Axioms Generate Main Triple row Table corresponding type ax' single main triple s p xlt then axiom ax translated following triples: s p xlt rdf:type owl:Axiom owl:annotatedSource s owl:annotatedProperty p owl:annotatedTarget xlt TANN(annotation1, TANN(annotationm, case ax' type SubClassOf, DisjointClasses classes, SubObjectPropertyOf property chain as subproperty expression, SubDataPropertyOf, ObjectPropertyDomain, DataPropertyDomain, ObjectPropertyRange, DataPropertyRange, InverseObjectProperties, FunctionalObjectProperty, FunctionalDataProperty, InverseFunctionalObjectProperty, ReflexiveObjectProperty, IrreflexiveObjectProperty, SymmetricObjectProperty, AsymmetricObjectProperty, TransitiveObjectProperty, DisjointObjectProperties properties, DisjointDataProperties properties, ClassAssertion, ObjectPropertyAssertion, DataPropertyAssertion, Declaration, DifferentIndividuals individuals, AnnotationAssertion. Consider following subclass axiom: SubClassOf( Annotation( rdfs:comment are people." annotation, axiom be translated following triple: rdfs:subClassOf Thus, annotated axiom transformed following triples: rdfs:subClassOf rdf:type owl:Axiom owl:annotatedSource owl:annotatedProperty rdfs:subClassOf owl:annotatedTarget rdfs:comment are people." ax' type DisjointUnion, SubObjectPropertyOf subproperty chain, HasKey, first triple corresponding row Table main triple subjected transformation described above; other triples corresponding row Table called side triples are output change. Consider following subproperty axiom: SubObjectPropertyOf( Annotation( rdfs:comment aunt mother's sister." ObjectPropertyChain( annotation, axiom be translated following triples: owl:propertyChainAxiom rdf:first rdf:rest rdf:first rdf:rest rdf:nil order capture annotation axiom, first triple plays role main triple axiom, so represented using fresh blank node order be able attach annotation original triple output other triples as rdf:type owl:Axiom owl:annotatedSource owl:annotatedProperty owl:propertyChainAxiom owl:annotatedTarget rdfs:comment aunt mother's sister." owl:propertyChainAxiom rdf:first rdf:rest rdf:first rdf:rest rdf:nil Consider following key axiom: HasKey( Annotation( rdfs:comment uniquely person." annotation, axiom be translated following triples: owl:hasKey rdf:first rdf:rest rdf:nil order capture annotation axiom, first triple plays role main triple axiom, so represented using fresh blank node order be able attach annotation rdf:type owl:Axiom owl:annotatedSource owl:annotatedProperty owl:hasKey owl:annotatedTarget rdfs:comment uniquely person." owl:hasKey rdf:first rdf:rest rdf:nil Axioms are Translated Multiple Triples axiom ax' type EquivalentClasses, EquivalentObjectProperties, EquivalentDataProperties, SameIndividual, translation RDF be broken up several RDF triples RDF only represent binary relations). case, RDF triples obtained translation ax' transformed as described previous section, annotations are repeated triples obtained translation. Consider following individual equality axiom: SameIndividual( Annotation( axiom first split following equalities pairs individuals, annotation repeated axiom obtained process: SameIndividual( Annotation( SameIndividual( Annotation( axioms now transformed triples as explained previous section: owl:sameAs rdf:type owl:Axiom owl:annotatedSource owl:annotatedProperty owl:sameAs owl:annotatedTarget owl:sameAs rdf:type owl:Axiom owl:annotatedSource owl:annotatedProperty owl:sameAs owl:annotatedTarget Axioms Represented Blank Nodes axiom ax' type NegativeObjectPropertyAssertion, NegativeDataPropertyAssertion, DisjointClasses more classes, DisjointObjectProperties more properties, DisjointDataProperties more properties, DifferentIndividuals more individuals, then translation already introducing blank node such cases, ax translated first translating ax' as shown Table then attaching annotations ax Consider following negative object property assertion: NegativeObjectPropertyAssertion( Annotation( Even annotation, axiom be represented using blank node. annotation readily be attached node, so axiom transformed following triples: rdf:type owl:NegativePropertyAssertion owl:sourceIndividual owl:assertionProperty owl:targetIndividual Mapping RDF Graphs Structural Specification section results steps CP CP canonical parsing process Section OWL Specification Specification] ontology document D be parsed RDF graph G. OWL tool MAY implement steps way however, results be structurally equivalent ones defined following sections. steps do not depend RDF syntax used encode RDF graph D; therefore, ontology document D identified section corresponding RDF graph G. RDF syntax ontology document document accessible given IRI be parsed RDF graph, then be transformed OWL ontology canonical parsing process instantiated as specified section. following sections contain rules triple patterns are matched G. Note triple pattern variable number triples, maximal possible subset G be matched. following notation used patterns: notation NN_INT(n) be matched literal value n nonnegative integer. Possible conditions pattern are enclosed curly braces patterns use optional parts, are enclosed square brackets abbreviation T(SEQ y1 yn) pattern corresponding RDF lists, as shown Table list pattern matched G, list variables j be matched different nodes; furthermore, NOT be possible match list pattern maximal subsets G such list variable first pattern instance matched same node as different) variable second pattern instance. necessary order detect malformed lists such as lists internal cycles, lists share tails, lists cross. Table Patterns Corresponding RDF Lists Sequence S Triples Corresponding T(S) Main Node T(S) SEQ rdf:nil SEQ y rdf:first y rdf:rest rdf:nil SEQ y1 yn n>1 rdf:first y1 rdf:rest rdf:first yn rdf:rest rdf:nil Extracting Declarations IRIs Directly Imported Ontology Documents section result step CP canonical parsing process RDF graph G. Resolving Included RDF Graphs backwards compatibility OWL DL, G owl:imports triple pointing RDF document encoding RDF graph G' G' not have ontology header, owl:imports triple interpreted as include rather import triples G' are included G are not parsed separate ontology. achieve following transformation applied G as long as following rule applicable G. G pair triples form rdf:type owl:Ontology owl:imports values have not already been considered, following actions are performed: document accessible IRI retrieved using augmented retrieval process Section OWL Specification Specification]. document parsed RDF graph G'. parsing graph G' not contain triple form rdf:type owl:Ontology. then G' merged RDF Semantics Semantics]) G triple owl:imports removed G. Parsing Ontology Header Declarations Next, ontology header extracted G matching patterns Table G. be possible match exactly such pattern G exactly way. matched triples are removed G. set Imp(G) IRIs ontology documents are directly imported G exactly are matched pattern. Table Parsing Ontology Header G pattern... ontology header form. rdf:type owl:Ontology owl:versionIRI owl:imports owl:imports k following triple pattern be matched G: rdf:type owl:Ontology rdf:type owl:OntologyProperty Ontology( Import( Import( rdf:type owl:Ontology owl:imports owl:imports k following triple pattern be matched G: rdf:type owl:Ontology rdf:type owl:OntologyProperty Ontology( Import( Import( Next, backwards compatibility OWL DL, certain redundant triples are removed G. particular, triple pattern left-hand side Table matched G, then triples right-hand side Table are removed G. Table Triples be Removed Backwards Compatibility OWL DL G pattern... triples are removed G. rdf:type owl:Ontology rdf:type owl:Ontology rdf:type owl:Class rdf:type rdfs:Class rdf:type rdfs:Class rdf:type rdfs:Datatype rdf:type rdfs:Class rdf:type rdfs:Class rdf:type owl:DataRange rdf:type rdfs:Class rdf:type rdfs:Class rdf:type owl:Restriction rdf:type rdfs:Class rdf:type rdfs:Class rdf:type owl:Restriction rdf:type owl:Class rdf:type owl:Class rdf:type owl:ObjectProperty rdf:type rdf:Property rdf:type rdf:Property rdf:type owl:FunctionalProperty rdf:type rdf:Property rdf:type rdf:Property rdf:type owl:InverseFunctionalProperty rdf:type rdf:Property rdf:type rdf:Property rdf:type owl:TransitiveProperty rdf:type rdf:Property rdf:type rdf:Property rdf:type owl:DatatypeProperty rdf:type rdf:Property rdf:type rdf:Property rdf:type owl:AnnotationProperty rdf:type rdf:Property rdf:type rdf:Property rdf:type owl:OntologyProperty rdf:type rdf:Property rdf:type rdf:Property rdf:type rdf:List rdf:first y rdf:rest rdf:type rdf:List Next, backwards compatibility OWL DL, G modified such declarations be properly extracted next step. triple pattern first column Table matched G, matching triples are replaced G triples second column. matching phase stops matching pattern replacing as specified not change G. Note G set thus contain duplicate triples, so last condition infinite matches. Table Additional Declaration Triples G pattern... matched triples are replaced G triples. rdf:type owl:OntologyProperty rdf:type owl:AnnotationProperty rdf:type owl:InverseFunctionalProperty rdf:type owl:ObjectProperty rdf:type owl:InverseFunctionalProperty rdf:type owl:TransitiveProperty rdf:type owl:ObjectProperty rdf:type owl:TransitiveProperty rdf:type owl:SymmetricProperty rdf:type owl:ObjectProperty rdf:type owl:SymmetricProperty Next, set declarations Decl(G) extracted G according Table matched triples are not removed G triples Table contain annotations so, order correctly parse annotations, be matched again step described Section Table Parsing Declarations G G pattern... declaration added Decl(G). rdf:type owl:Class Declaration( Class( rdf:type rdfs:Datatype Declaration( Datatype( rdf:type owl:ObjectProperty Declaration( ObjectProperty( rdf:type owl:DatatypeProperty Declaration( DataProperty( rdf:type owl:AnnotationProperty Declaration( AnnotationProperty( rdf:type owl:NamedIndividual Declaration( NamedIndividual( rdf:type owl:Axiom owl:annotatedSource owl:annotatedProperty rdf:type owl:annotatedTarget owl:Class Declaration( Class( rdf:type owl:Axiom owl:annotatedSource owl:annotatedProperty rdf:type owl:annotatedTarget rdfs:Datatype Declaration( Datatype( rdf:type owl:Axiom owl:annotatedSource owl:annotatedProperty rdf:type owl:annotatedTarget owl:ObjectProperty Declaration( ObjectProperty( rdf:type owl:Axiom owl:annotatedSource owl:annotatedProperty rdf:type owl:annotatedTarget owl:DatatypeProperty Declaration( DataProperty( rdf:type owl:Axiom owl:annotatedSource owl:annotatedProperty rdf:type owl:annotatedTarget owl:AnnotationProperty Declaration( AnnotationProperty( rdf:type owl:Axiom owl:annotatedSource owl:annotatedProperty rdf:type owl:annotatedTarget owl:NamedIndividual Declaration( NamedIndividual( Finally, set RIND blank nodes used reification identified. done initially setting RIND then applying patterns shown Table matched triples are not deleted G. Table Identifying Reification Blank Nodes G pattern, then added RIND. rdf:type owl:Axiom rdf:type owl:Annotation rdf:type owl:AllDisjointClasses rdf:type owl:AllDisjointProperties rdf:type owl:AllDifferent rdf:type owl:NegativePropertyAssertion Populating Ontology section result step CP canonical parsing process RDF graph G, corresponding instance OG Ontology class, set AllDecl(G) declarations G computed as specified step CP canonical parsing process. Analyzing Declarations following functions map IRI blank node occurring G object structural specification. particular, CE(x) maps class expression, DR(x) maps data range, OPE(x) maps object property expression, DPE(x) maps data property expression, AP(x) maps annotation property. Initially, functions are undefined IRIs blank nodes occurring G; written as CE(x) Îµ, DR(x) Îµ, OPE(x) Îµ, DPE(x) Îµ, AP(x) Îµ. functions are updated as parsing following conditions be satisfied given point time parsing. x, most OPE(x), DPE(x), AP(x) defined. x, most CE(x) DR(x) defined. Furthermore, value functions NOT be redefined parsing function not undefined x, attempt be made change function's value Functions CE, DR, OPE, DPE, AP are initialized as shown Table Table Initialization CE, DR, OPE, DPE, AP AllDecl(G) declaration... perform assignment. Declaration( Class( CE(*:x) class IRI Declaration( Datatype( DR(*:x) datatype IRI Declaration( ObjectProperty( OPE(*:x) object property IRI Declaration( DataProperty( DPE(*:x) data property IRI Declaration( AnnotationProperty( AP(*:x) annotation property IRI Parsing Annotations annotations G are parsed next. function ANN set annotations ANN(x) IRI blank node x. function initialized setting ANN(x) IRI blank node x. Next, triple patterns Table are matched G matched pattern, ANN(x) extended annotation column. time triple patterns matched, matched triples are removed G. process repeated further matches are possible. Table Parsing Annotations G pattern... annotation added ANN(x). xlt AP(*:y) Îµ there blank node such G following triples: rdf:type owl:Annotation owl:annotatedSource owl:annotatedProperty owl:annotatedTarget xlt Annotation( xlt xlt rdf:type owl:Annotation owl:annotatedSource owl:annotatedProperty owl:annotatedTarget xlt AP(*:y) Îµ other triple G subject object position Annotation( ANN(_:w) xlt Parsing Ontology Annotations Let be node was matched G according patterns Table then, ANN(x) set ontology annotations OG. Parsing Expressions Next, functions OPE, DR, CE are extended as shown Tables as as Tables patterns latter tables are not generated mapping Section be present RDF graphs encode OWL DL ontologies. time pattern matched, matched triples are removed G. Pattern matching repeated triple pattern be matched G. Table Parsing Object Property Expressions G pattern... OPE(_:x) set object property expression. owl:inverseOf OPE(_:x) Îµ OPE(*:y) Îµ ObjectInverseOf( OPE(*:y) Table Parsing Data Ranges G pattern... DR(_:x) set data range. rdf:type rdfs:Datatype owl:intersectionOf T(SEQ y1 yn) n DR(yi) Îµ n DataIntersectionOf( DR(y1) DR(yn) rdf:type rdfs:Datatype owl:unionOf T(SEQ y1 yn) n DR(yi) Îµ n DataUnionOf( DR(y1) DR(yn) rdf:type rdfs:Datatype owl:datatypeComplementOf y DR(y) Îµ DataComplementOf( DR(y) rdf:type rdfs:Datatype owl:oneOf T(SEQ lt1 ltn) n DataOneOf( lt1 ltn rdf:type rdfs:Datatype owl:onDatatype owl:withRestrictions T(SEQ lt1 ltn DR(*:y) datatype DatatypeRestriction( DR(*:y) lt1 ltn Table Parsing Class Expressions G pattern... CE(_:x) set class expression. rdf:type owl:Class owl:intersectionOf T(SEQ y1 yn) n CE(yi) Îµ n ObjectIntersectionOf( CE(y1) CE(yn) rdf:type owl:Class owl:unionOf T(SEQ y1 yn) n CE(yi) Îµ n ObjectUnionOf( CE(y1) CE(yn) rdf:type owl:Class owl:complementOf y CE(y) Îµ ObjectComplementOf( CE(y) rdf:type owl:Class owl:oneOf T(SEQ n ObjectOneOf( rdf:type owl:Restriction owl:onProperty y owl:someValuesFrom OPE(y) Îµ CE(z) Îµ ObjectSomeValuesFrom( OPE(y) CE(z) rdf:type owl:Restriction owl:onProperty y owl:allValuesFrom OPE(y) Îµ CE(z) Îµ ObjectAllValuesFrom( OPE(y) CE(z) rdf:type owl:Restriction owl:onProperty y owl:hasValue OPE(y) Îµ ObjectHasValue( OPE(y) rdf:type owl:Restriction owl:onProperty y owl:hasSelf OPE(y) Îµ ObjectHasSelf( OPE(y) rdf:type owl:Restriction owl:minQualifiedCardinality NN_INT(n) owl:onProperty y owl:onClass OPE(y) Îµ CE(z) Îµ ObjectMinCardinality( n OPE(y) CE(z) rdf:type owl:Restriction owl:maxQualifiedCardinality NN_INT(n) owl:onProperty y owl:onClass OPE(y) Îµ CE(z) Îµ ObjectMaxCardinality( n OPE(y) CE(z) rdf:type owl:Restriction owl:qualifiedCardinality NN_INT(n) owl:onProperty y owl:onClass OPE(y) Îµ CE(z) Îµ ObjectExactCardinality( n OPE(y) CE(z) rdf:type owl:Restriction owl:minCardinality NN_INT(n) owl:onProperty y OPE(y) Îµ ObjectMinCardinality( n OPE(y) rdf:type owl:Restriction owl:maxCardinality NN_INT(n) owl:onProperty y OPE(y) Îµ ObjectMaxCardinality( n OPE(y) rdf:type owl:Restriction owl:cardinality NN_INT(n) owl:onProperty y OPE(y) Îµ ObjectExactCardinality( n OPE(y) rdf:type owl:Restriction owl:onProperty y owl:hasValue lt DPE(y) Îµ DataHasValue( DPE(y) lt rdf:type owl:Restriction owl:onProperty y owl:someValuesFrom DPE(y) Îµ DR(z) Îµ DataSomeValuesFrom( DPE(y) DR(z) rdf:type owl:Restriction owl:onProperties T(SEQ y1 yn) owl:someValuesFrom n DPE(yi) Îµ n, DR(z) Îµ DataSomeValuesFrom( DPE(y1) DPE(yn) DR(z) rdf:type owl:Restriction owl:onProperty y owl:allValuesFrom DPE(y) Îµ DR(z) Îµ DataAllValuesFrom( DPE(y) DR(z) rdf:type owl:Restriction owl:onProperties T(SEQ y1 yn) owl:allValuesFrom n DPE(yi) Îµ n, DR(z) Îµ DataAllValuesFrom( DPE(y1) DPE(yn) DR(z) rdf:type owl:Restriction owl:minQualifiedCardinality NN_INT(n) owl:onProperty y owl:onDataRange DPE(y) Îµ DR(z) Îµ DataMinCardinality( n DPE(y) DR(z) rdf:type owl:Restriction owl:maxQualifiedCardinality NN_INT(n) owl:onProperty y owl:onDataRange DPE(y) Îµ DR(z) Îµ DataMaxCardinality( n DPE(y) DR(z) rdf:type owl:Restriction owl:qualifiedCardinality NN_INT(n) owl:onProperty y owl:onDataRange DPE(y) Îµ DR(z) Îµ DataExactCardinality( n DPE(y) DR(z) rdf:type owl:Restriction owl:minCardinality NN_INT(n) owl:onProperty y DPE(y) Îµ DataMinCardinality( n DPE(y) rdf:type owl:Restriction owl:maxCardinality NN_INT(n) owl:onProperty y DPE(y) Îµ DataMaxCardinality( n DPE(y) rdf:type owl:Restriction owl:cardinality NN_INT(n) owl:onProperty y DPE(y) Îµ DataExactCardinality( n DPE(y) Table Parsing Data Ranges Compatibility OWL DL G pattern... DR(_:x) set object property expression. rdf:type owl:DataRange owl:oneOf T(SEQ lt1 ltn) n DataOneOf( lt1 ltn rdf:type owl:DataRange owl:oneOf T(SEQ) DataComplementOf( rdfs:Literal Table Parsing Class Expressions Compatibility OWL DL G pattern... CE(_:x) set class expression. rdf:type owl:Class owl:unionOf T(SEQ) owl:Nothing rdf:type owl:Class owl:unionOf T(SEQ y) CE(y) Îµ CE(y) rdf:type owl:Class owl:intersectionOf T(SEQ) owl:Thing rdf:type owl:Class owl:intersectionOf T(SEQ y) CE(y) Îµ CE(y) rdf:type owl:Class owl:oneOf T(SEQ) owl:Nothing Parsing Axioms Next, OG populated axioms. clarity, axiom patterns are split tables. Table presents patterns axioms annotations. Annotated axioms are parsed as case patterns owl:AllDisjointClasses, owl:AllDisjointProperties, owl:AllDifferent, owl:NegativePropertyAssertion, axiom annotations are defined ANN(_:x). other axioms, axiom annotations are obtained additionally matching patterns Table G axiom matching. axioms G are parsed as annotated axioms are parsed first. Only pattern annotated axioms be matched G, then patterns axioms annotations are matched. either case, time triple pattern matched, matched triples are removed G. Table Parsing Axioms Annotations G pattern... following axiom added OG. rdf:type owl:Class Declaration( Class( rdf:type rdfs:Datatype Declaration( Datatype( rdf:type owl:ObjectProperty Declaration( ObjectProperty( rdf:type owl:DatatypeProperty Declaration( DataProperty( rdf:type owl:AnnotationProperty Declaration( AnnotationProperty( rdf:type owl:NamedIndividual Declaration( NamedIndividual( rdfs:subClassOf y CE(x) Îµ CE(y) Îµ SubClassOf( CE(x) CE(y) owl:equivalentClass y CE(x) Îµ CE(y) Îµ EquivalentClasses( CE(x) CE(y) owl:disjointWith y CE(x) Îµ CE(y) Îµ DisjointClasses( CE(x) CE(y) rdf:type owl:AllDisjointClasses owl:members T(SEQ y1 yn) n CE(yi) Îµ n DisjointClasses( CE(y1) CE(yn) owl:disjointUnionOf T(SEQ y1 yn) n CE(x) Îµ, CE(yi) Îµ n DisjointUnion( CE(*:x) CE(y1) CE(yn) rdfs:subPropertyOf y OPE(x) Îµ OPE(y) Îµ SubObjectPropertyOf( OPE(x) OPE(y) owl:propertyChainAxiom T(SEQ y1 yn) n OPE(yi) Îµ n, OPE(x) Îµ SubObjectPropertyOf( ObjectPropertyChain( OPE(y1) OPE(yn) OPE(x) owl:equivalentProperty y OPE(x) Îµ OPE(y) Îµ EquivalentObjectProperties( OPE(x) OPE(y) owl:propertyDisjointWith y OPE(x) Îµ OPE(y) Îµ DisjointObjectProperties( OPE(x) OPE(y) rdf:type owl:AllDisjointProperties owl:members T(SEQ y1 yn) n OPE(yi) Îµ n DisjointObjectProperties( OPE(y1) OPE(yn) rdfs:domain y OPE(x) Îµ CE(y) Îµ ObjectPropertyDomain( OPE(x) CE(y) rdfs:range y OPE(x) Îµ CE(y) Îµ ObjectPropertyRange( OPE(x) CE(y) owl:inverseOf y OPE(x) Îµ OPE(y) Îµ InverseObjectProperties( OPE(x) OPE(y) rdf:type owl:FunctionalProperty OPE(x) Îµ FunctionalObjectProperty( OPE(x) rdf:type owl:InverseFunctionalProperty OPE(x) Îµ InverseFunctionalObjectProperty( OPE(x) rdf:type owl:ReflexiveProperty OPE(x) Îµ ReflexiveObjectProperty( OPE(x) rdf:type owl:IrreflexiveProperty OPE(x) Îµ IrreflexiveObjectProperty( OPE(x) rdf:type owl:SymmetricProperty OPE(x) Îµ SymmetricObjectProperty( OPE(x) rdf:type owl:AsymmetricProperty OPE(x) Îµ AsymmetricObjectProperty( OPE(x) rdf:type owl:TransitiveProperty OPE(x) Îµ TransitiveObjectProperty( OPE(x) rdfs:subPropertyOf y DPE(x) Îµ DPE(y) Îµ SubDataPropertyOf( DPE(x) DPE(y) owl:equivalentProperty y DPE(x) Îµ DPE(y) Îµ EquivalentDataProperties( DPE(x) DPE(y) owl:propertyDisjointWith y DPE(x) Îµ DPE(y) Îµ DisjointDataProperties( DPE(x) DPE(y) rdf:type owl:AllDisjointProperties owl:members T(SEQ y1 yn) n DPE(yi) Îµ n DisjointDataProperties( DPE(y1) DPE(yn) rdfs:domain y DPE(x) Îµ CE(y) Îµ DataPropertyDomain( DPE(x) CE(y) rdfs:range y DPE(x) Îµ DR(y) Îµ DataPropertyRange( DPE(x) DR(y) rdf:type owl:FunctionalProperty DPE(x) Îµ FunctionalDataProperty( DPE(x) owl:equivalentClass y DR(*:x) Îµ amd DR(y) Îµ DatatypeDefinition( DR(*:x) DR(y) owl:hasKey T(SEQ y1 yk) CE(x) Îµ, sequence y1 yk be partitioned disjoint sequences z1 zm w1 wn such m n OPE(zi) Îµ m DPE(wj) Îµ j n HasKey( CE(x) OPE(z1) OPE(zm) DPE(w1) DPE(wn) owl:sameAs y SameIndividual( y owl:differentFrom y DifferentIndividuals( y rdf:type owl:AllDifferent owl:members T(SEQ x1 xn) n DifferentIndividuals( x1 xn rdf:type owl:AllDifferent owl:distinctMembers T(SEQ x1 xn) n DifferentIndividuals( x1 xn rdf:type y CE(y) Îµ ClassAssertion( CE(y) OPE(*:y) Îµ ObjectPropertyAssertion( OPE(*:y) rdf:type owl:NegativePropertyAssertion owl:sourceIndividual owl:assertionProperty y owl:targetIndividual OPE(y) Îµ NegativeObjectPropertyAssertion( OPE(y) lt DPE(*:y) Îµ DataPropertyAssertion( DPE(*:y) lt rdf:type owl:NegativePropertyAssertion owl:sourceIndividual owl:assertionProperty y owl:targetValue lt DPE(y) Îµ NegativeDataPropertyAssertion( DPE(y) lt rdf:type owl:DeprecatedClass AnnotationAssertion( owl:deprecated rdf:type owl:DeprecatedProperty AnnotationAssertion( owl:deprecated rdfs:subPropertyOf AP(*:x) Îµ AP(*:y) Îµ SubAnnotationPropertyOf( AP(*:x) AP(*:y) rdfs:domain AP(*:x) Îµ AnnotationPropertyDomain( AP(*:x) rdfs:range AP(*:x) Îµ AnnotationPropertyRange( AP(*:x) Table Parsing Annotated Axioms G pattern... following axiom added OG. s xlt rdf:type owl:Axiom owl:annotatedSource s owl:annotatedProperty owl:annotatedTarget xlt s xlt main triple axiom according Table G possible necessary side triples axiom result axiom corresponding s xlt possible side triples) additionally annotations ANN(_:x). Next, blank node IRI such RIND, annotationAnnotation( annotation1 annotationn AP y ANN(x) n possibly being equal following annotation assertion added OG: AnnotationAssertion( annotation1 annotationn AP y Finally, patterns Table are matched G resulting axioms are added OG. patterns are not generated mapping Section be present RDF graphs encode OWL DL ontologies. patterns table do not contain triples form rdf:type owl:Class because such triples are removed parsing entity declarations, as specified Section time triple pattern matched, matched triples are removed G. Table Parsing Axioms Compatibility OWL DL G pattern... following axiom added OG. owl:complementOf y CE(*:x) Îµ CE(y) Îµ EquivalentClasses( CE(*:x) ObjectComplementOf( CE(y) owl:unionOf T(SEQ) CE(*:x) Îµ EquivalentClasses( CE(*:x) owl:Nothing owl:unionOf T(SEQ y) CE(*:x) Îµ CE(y) Îµ EquivalentClasses( CE(*:x) CE(y) owl:unionOf T(SEQ y1 yn) n CE(*:x) Îµ, CE(yi) Îµ n EquivalentClasses( CE(*:x) ObjectUnionOf( CE(y1) CE(yn) owl:intersectionOf T(SEQ) CE(*:x) Îµ EquivalentClasses( CE(*:x) owl:Thing owl:intersectionOf T(SEQ y) CE(*:x) Îµ CE(y) Îµ EquivalentClasses( CE(*:x) CE(y) owl:intersectionOf T(SEQ y1 yn) n CE(*:x) Îµ, CE(yi) Îµ n EquivalentClasses( CE(*:x) ObjectIntersectionOf( CE(y1) CE(yn) owl:oneOf T(SEQ) CE(*:x) Îµ EquivalentClasses( CE(*:x) owl:Nothing owl:oneOf T(SEQ n CE(*:x) Îµ EquivalentClasses( CE(*:x) ObjectOneOf( end process, graph G be empty. Appendix: Change Log Changes Recommendation section changes document since Recommendation October, publication XML Schema Definition Language Part Datatypes Recommendation April elements OWL are based XSD are now considered required, note detailing optional dependency XSD Candidate Recommendation April, been removed Document" section. Minor typographical errors were corrected as detailed OWL Errata page. Changes Proposed Recommendation section changes document since Proposed Recommendation September, arguments ClassAssertion axiom Table were swapped bring axiom line functional-style syntax. Changes Candidate Recommendation section changes document since Candidate Recommendation June, minor bugs were fixed reverse mappings inverseOf hasKey. Changes Last Call section changes document since Last Call Working Draft April, RDF vocabulary annotations was changed: owl:subject, owl:predicate owl:object became, respectively, owl:annotatedSource, owl:annotatedProperty owl:annotatedTarget. Several lists syntax were updated track previous change Structural Specification Functional-Style Syntax. examples were fixed. minor editorial changes were made. Acknowledgments starting point development OWL was OWL1.1 member submission, result user developer feedback, particular information gathered OWL Experiences Directions Workshop series. working group also considered postponed issues WebOnt Working Group. document been produced OWL Working Group below), contents reflect extensive discussions Working Group as whole.The editors extend special thanks toMarkus KrÃ¶tzsch Ruttenberg Commons),Uli Sattler Manchester),Michael Schneider andEvren Sirin Parsia)for thorough reviews. regular attendees meetings OWL Working Group time publication document were:Jie Bao Calvanese University Bozen-Bolzano),Bernardo Cuenca Grau University Computing Laboratory),Martin Dzbor University),Achille Fokoue Corporation),Christine Golbreich de Versailles St-Quentin LIRMM),Sandro Hawke Herman Hoekstra Amsterdam),Ian Horrocks University Computing Laboratory),Elisa Kendall Software),Markus KrÃ¶tzsch Lutz Bremen),Deborah L. McGuinness Motik University Computing Laboratory),Jeff Pan Aberdeen),Bijan Parsia Manchester),Peter F. Patel-Schneider Labs Research, Alcatel-Lucent),Sebastian Rudolph Ruttenberg Commons),Uli Sattler Manchester),Michael Schneider Smith Parsia),Evan Wallace Wu Corporation), andAntoine Zimmermann Galway).We also thank past members working group:Jeremy Carroll,Jim Hendler, andVipul Kashyap. References Specification] OWL Web Ontology Language: Structural Specification Functional-Style Syntax Edition) Boris Motik, Peter F. Patel-Schneider, Bijan Parsia, eds. W3C Recommendation, December Latest version available Concepts] Resource Description Framework Concepts Abstract Syntax. Graham Klyne Jeremy J. Carroll, eds. W3C Recommendation, February Latest version available as Semantics] RDF Semantics. Patrick Hayes, ed., W3C Recommendation, February Latest version available as RFC Key words use RFCs Indicate Requirement Levels. Network Working Group, S. Bradner. IETF, March 