XML Schema Datatypes RDF OWL XML Schema Datatypes RDF OWL W3C Working Group Note March version: Latest version: Previous version: Editors: Jeremy J. Carroll, HP Lab Jeff Z. Pan, University Aberdeen Copyright W3C® ERCIM, Keio), Rights Reserved. W3C liability, trademark document use rules apply. Abstract RDF OWL Recommendations use simple types XML Schema. document addresses questions left unanswered Recommendations: URIref be used refer user defined datatype? values XML Schema simple types are same? use problematic xsd:duration RDF OWL? addition, further describe integrate OWL DL user defined datatypes appendix B). Status Document section status document time publication. Other documents supersede document. list current W3C publications latest revision technical report be found W3C technical reports index document Working Group Note, produced Semantic Web Best Practices Deployment Working Group, part W3C Semantic Web Activity. publication Working Group Note SWBPD Working Group completed work document. Changes previous Working Draft are summarized Appendix C. Comments document be sent public-swbp-wg@w3.org, mailing list public archive. Further discussion material be sent Semantic Web Interest Group mailing list, semantic-web@w3.org, also public archive. document was produced group operating February W3C Patent Policy. document informative only. W3C public list patent disclosures made connection deliverables group; page also instructions disclosing patent. Publication as Working Group Note not imply endorsement W3C Membership. draft document be updated, replaced obsoleted other documents time. inappropriate cite document as other work progress. Table Contents Introduction Reading Document Namespaces Used Document XML Schema Simple Types User Defined Datatypes Problem Statement Component Designators Solution Using id Attribute Suggested Practice Comparison Values Problem Statement Primitive Types Differ Formal Analysis Examples Using SPARQL Equality Value Approximate Mapping Duration Use Numeric Types Acknowledgements References Appendix Semantics Datatyping Semantic Web Recommendations A.1 Datatypes RDF A.2 Datatypes OWL DL Appendix B: Integrating Description Logics User-Defined Datatypes Appendix C: Changes since Working Draft April Introduction overview datatype abstraction used RDF found Concepts Abstract Syntax]; shared Abstract Syntax]. semantics RDF datatyping OWL datatyping are summarized appendix A. RDF OWL allow use typed literal values description resources ontologies. Primer], Guide] more introductory treatments RDF OWL. Semantics] Semantics] use lexical-to-value mapping datatype give interpretation value) typed literal, thus semantics typed literals given type system. type systems are defined externally RDF OWL, most notably Schema2]. Concrete syntaxes typed literals are found Syntax], questions about XML Schema datatypes Semantic Web are not directly answered published W3C Recommendations. document RDF OWL, refer XML Schema user defined simple type URI. Details denotational semantics values primitive XML Schema simple types. XML Schema principally operational semantics. RDF OWL applications need denotational semantics interoperable behaviour. possible solution problems concerning xsd:duration, are reported Semantics]. Appropriate use numeric types engineering applications. Reading Document document be read start finish, many readers benefit skipping sections. intended reader informed about RDF OWL, be creator user metadata ontologies, be implementor systems implement RDF OWL Recommendations, be author editor related specifications. reader interested defining own datatypes read section maybe appendix B, formal treatment, terms OWL DL user defined datatypes, not been covered Semantics]. reader interested correct use datatypes read section concerning values are same, section concerning numerics, particularly, not exclusively, engineering applications. Implementors probably read most document: appendix formal treatment datatyping recommendations; section extended discussion about equality; section mapping URIs user defined types. Readers most interested formal semantics find most value appendix B, concerning user defined datatypes, section concerning equality. Such readers start reviewing appendix be familiar. Section durations, more limited interest, significant reader wishes use, implement build top duration datatypes. Namespaces Used Document document use N3 such as following subset used Test Cases], following namespace prefixes: @prefix dc: .@prefix eg: .@prefix egdt: .@prefix xsd: .@prefix rdf: .@prefix rdfs: .@prefix owl: .@prefix xsd: XML Schema Simple Types SCHEMA2] facilities defining simple types be used XML Schema as as other XML specifications. influenced earlier work datatypes such as XML Schema simple type d characterised value space, V(d), non-empty set, lexical space, L(d), non-empty set Unicode strings, set facets, F(d), value space along independent axes dimensions. XML Schema simple types are divided disjoint built-in simple types derived simple types. Derived datatypes be defined primitive existing derived datatypes following means: restriction, i.e., using facets existing type, so as limit number possible values derived type. union, i.e., allow values list simple types. list, i.e., define list type existing simple type. Example 1A following definition derived simple type base datatype xsd:integer) values integers greater equal less using facets minInclusive maxExclusive. name="humanAge"> base="integer"> value="0"> value="150"> User Defined Datatypes Schema2] predefines about simple types, ones suitable RDF OWL are listed Semantics]. addition, XML Schema permits users refine builtin types taking restriction including only values lexical forms. Example 2A further example, wish talk about ages adults years, adult over be described as restriction xsd:integer datatype. name="adultAge"> base="integer"> value="18"> Semantic Web context be used objects triples eg:age property, used, instance, describing members club restricted adults, e.g. nightclub political party. use example section, assume be retrieved RDF, RDF reasoning, additional restriction be enough catch typos data entry errors putting inappropriate value eg:age property). OWL, OWL reasoning, interact axioms ontology significantly restrict possible interpretations, adding modelling power language. section only deals problem refer such datatypes. semantics treated appendices. Appendix reviews semantics datatypes RDF OWL recommendations. Appendix B integrate Description Logics as SHOIN DL, underpinning OWL DL) user defined datatypes. also consider topic target namespace SCHEMA1]. clarity, consider variants example. first target namespace, second Example 2B xmlns:xs="http://www.w3.org/2001/XMLSchema"> name="adultAge"> base="integer"> value="18"> Example 2C targetNamespace="http://example.org/ns" elementFormDefault="qualified" xmlns:egn="http://example.org/ns" xmlns:xs="http://www.w3.org/2001/XMLSchema"> name="adultAge"> base="integer"> value="18"> case XML Schema been assembed multiple schema documents lies outside scope document. case discussed SCHEMA1] explicitly not discussed Problem Statement: describing resource RDF building ontology OWL, user defined simple XML Schema datatype, such as adultAge above, URI be used identify datatype? Component Designators Solution Following XML Schema Component Designators Example 2B URI reference URI reference Example 2C choice prefix namespace good choice use prefix used schema i.e. egn. resulting URI reference datatype then schema not define prefix target namespace, perhaps using default namespace, then arbitrary prefix needs be chosen. always namespace prefixes, permitted use prefix choice, even conventional prefix used schema document. XML Schema Component Designators XPointer scheme XML Schema document identify schema components using fragment. very general: fragments are defined identify many different aspects document, including unnamed simple types complex schema. example 2B eg:membersAge rdfs:range eg:name Doe" eg:membersAge way reading fragment full semantic clarity about being identified: xscd(.) shows XML Schema component being identified; type being identified; shows type being identified. above URIrefs be abbreviated eg:membersAge rdfs:range egdt:xscd(/type::adultAge) eg:name Doe" eg:membersAge because xscd(/type::adultAge) not match NCName production. Overall, referring XML Schema Datatypes manner proposed XML Schema Working Group good practice, be moreso, reaches Recommendation status. Using id Attribute cases XML Schema control Semantic Web author, full generality not needed. section shows defining own datatype, derived XML Schema type, possible use simpler method, slightly modifying schema defining datatype. Example 2A id="adultAge" name="adultAge"> base="integer"> value="18"> difference datatype wish use not only identified @name attribute, also @id attribute. technically possibly use different values attributes, be confusing. URI reference then be used refer datatype. terminology URI secondary resource. retrieved as XML Schema document, mimetype application/xml, be taken as shorthand pointer Framework]. view XML representation primary resource being XML element matching @id attribute. used RDF Concepts], URI reference be understood URI as identifying schema, URI as identifying datatype resource defined described representation identified application/xml retrieval. preferred targetNamespace given schema usage. there @id attribute given name, Framework] clear error: element information item identified shorthand pointer's NCName, pointer error. example RDF eg:membersAge rdfs:range eg:name Doe" eg:membersAge eg:membersAge rdfs:range egdt:adultAge eg:name Doe" eg:membersAge further example, club members ages, wishes have class adult members, use OWL expression following Abstract Syntax]: Class(AdultMembers insersectionOf( Members Restriction(eg:membersAge, allValuesFrom(egdt:adultAge)) Suggested Practice referring arbitrary user defined datatypes arbitrary XML Schema, solution appropriate. RDF OWL author tool writing XML Schema use RDF/XML document, @id solution be preferred. Comparison Values different authors publishing same information Semantic Web make different syntactic choices. then same thing different ways. seen most clearly documents entail as determined Semantics] Semantics]. aspect syntactic choices facing author datatypes use. Even use only built SCHEMA2] simple types, there are non-trivial choices, different authors legitimately choose different datatypes. section addresses issue implementations Semantics] Semantics] allow different choices datatype made different authors. Problem Statement relationship value spaces various XML Schema built-in simple types used RDF OWL? other words, do literals, are written down differently, refer same value. example, denote integer Primitive Types Differ most appropriate solution primitive XML Schema Datatypes are treated as having disjoint value spaces. approach easy understand, easy implement. Formally, unary datatype group, value spaces primitive base datatypes are required be defined as disjoint other. instance, value space datatype D1 subset datatype D2, then D1 D2 not be primitive base datatypes unary datatype group. Formal Analysis discussing examples, presented pairs literals denoted same value. relationship denoting same value forms equivalence relation, write as conventionally written as called equality. reflexive, symmetric transitive. terms Semantics] appendix A.1) equivalence relation be constructed interpretation function IL, following way: IL(x)=IL(y), x, y LV terms Semantics] appendix A.2), be constructed terms interpretation function ED ED(x)=ED(y), x, y LV key term use following examples, primitive base datatype type system. recursive definition built primitive datatype own primitive base datatype. primitive base datatype derived simple type primitive base datatype base datatype. other words, primitive base datatype type system found walking up restriction tree reaching primitive type. Note concept primitive base datatypes type system slightly different concept primitive base datatypes unary datatype group. because possible primitive base datatype type system not datatype map, derived datatypes are. instance, Example_B, xsd:integer primitive base datatype unary datatype group G1. Examples give sets examples. first set examples, depend comparisons primitive base datatype same. second set primitive base datatype not. However, second set are intended be slightly counter-intuitive, illustrate limitations approach comparing typed literals. example presented ways: pair literals not, denote same value. possible entailment. Technically intended entailment D-entailment, terms Semantics], OWL Full entailment terms Semantics]. Similar, slightly longer, OWL DL entailments be constructed, illustrating same issues. Easy Examples uncontested SCHEMA2] datatype derived restriction subset values base datatype, not different values SCHEMA2]). Hence, typed literals type have same primitive base datatype, lexical forms are equivalent, are equal. addition, Semantics] explicitly sanctions identification RDF plain literals language tags corresponding typed literals datatype xsd:string. Derived Numerics first example denote same value, because xsd:byte primitive base datatype xsd:decimal. licenses following entailment: Example 3A eg:Jane eg:age eg:Jane eg:age same result types have primitive base datatype decimal. example denote entailment: Example 3B eg:Jane eg:age eg:Jane eg:age Note xsd:byte not derived xsd:nonNegativeInteger, vice versa, even intermediate steps. Derived Strings xsd:language primitive base datatype xsd:string. Thus denote same value, following entailment Example 3C eg:doc dc:language eg:doc dc:language However, language identifier being case insensitive according case insensitivity not represented datatype, so denote different values have following non-entailment: Example 3D eg:doc dc:language not entail eg:doc dc:language Plain Strings Semantics] informative section): value space lexical-to-value mapping XSD datatype xsd:string sanctions identification typed literals plain literals language tags character strings are lexical space datatype, since denote Unicode character string displayed literal; Thus same as plain literal following entailments hold: Example 3E eg:doc dc:language eg:doc dc:language Example 3F eg:doc dc:language eg:doc dc:language Hard Examples typed literals being compared have different primitive base datatypes, values are assumed be different, entailments do not follow, even counterintuitive. number instance be float, double, decimal. have different primitive base datatypes, are different. Float Decimal human age conventionally given as integer years, babies). float plausible alternative representation. April 7th Jeremy was different primitive basetype so are not equal Example 3G eg:JeremyCarroll eg:ageInYears not entail eg:JeremyCarroll eg:ageInYears Similarly, float double are different primitive base datatypes, so superficially similar values, such as are different, Example 3H eg:car eg:engineSizeInLitres not entail eg:car eg:engineSizeInLitres Float Double float decimal, float double derived other. Thus, are treated as not equal, Example 3J eg:JeremyCarroll eg:ageInYears not entail eg:JeremyCarroll eg:ageInYears Similarly: Example 3K eg:car eg:engineSizeInLitres not entail eg:car eg:engineSizeInLitres String anyURI Similarly, types string anyURI, are distinct primitive base datatypes. So superficial similarities, different Example 3L eg:doc dc:identifier not entail eg:doc dc:identifier hexBinary base64Binary final case value spaces XML Schema simple types appear same xsd:hexBinary xsd:base64Binary. value space described set finite-length sequences binary octets. instance binary sequence octets integer be written hexadecmial as 0FB7. base64 encoding same sequence octets represented as D7c=. types hexBinary base64Binary, are distinct primitive base datatypes. So different Example 3M eg:doc eg:checkSum not entail eg:doc eg:checkSum Using SPARQL Equality non-entailments shown be counterintuitive, possible use SPARQL query graph retrieve literal values are similar even not derived same primitive base type. example, related examples 3H 3K. Given graph including following triples: eg:car eg:engineSizeInLitres eg:engineSizeInLitres eg:engineSizeInLitres following query match SELECT eg:car eg:engineSizeInLitres FILTER current working draft, mapping typedliteral, as syntactic object, corresponding value, done aspart operation operator above query, ratherthanas part D-interpretation Semantics].This mapping specified Operators], being strongly typed, not identical specified Semantics] Value Approximate Mapping different approach, better embedded Semantics], enablemeaningful mappings values different datatypes.This give better foundations operations such as typepromotion XML Path Language operator inSPARQL mentioned Section quick sketch extend theRDF D-interpretation support value approximate maps, as value approximate map mapsTois partial mapping typed literals typed literals. Example 3N example value approximate mapping owlx:mapsTo Given datatype map D value approximate map mapsTo, approximate equality aeq defined as aeq("s1"^^u1, L2S(D(u1))(s1) L2S(D(u2))(s2) mapsTo("s1"^^u1)="s3"^^u2 L2S(D(u2))(s3) L2S(D(u2))(s2), aeq("s1"^^u1, otherwise. Note according above definition, aeq("s1"^^u1, not imply are interpreted as same value L2S(D(u2))(s2)). approximate equality different equality not necessarily symmetric, depending corresponding value approxiate map. unsymmetry needed support e.g. type promotions XML Path Language Note notion value approxiate mappings very general not disallow having symmetric mappings typed literals. Example 3N, also specify value approximate mapping make mappings typed literals symmetric. sum up, applications specify value approximate map mapsTo make use approximate equality aeq purposes. Duration Semantics] Recommendation use xsd:duration datatype SCHEMA2]). built-in XML Schema datatypes are unsuitable various reasons, NOT be used: xsd:duration not have well-defined value space be corrected later revisions XML Schema datatypes, case revised datatype be suitable use RDF datatyping); underlying difficulty impossibility unequivocal answer question many days month?" proved problematic other applications XML Schema datatypes. XQuery XSLT Working Groups have proposed solution. derive new datatypes, xdt:yearMonthDuration xdt:dayTimeDuration xsd:duration, sidestepping unanswerable question. section Operators] read: xdt:yearMonthDuration derived xs:duration restricting lexical representation contain only year month components. value space xdt:yearMonthDuration set xs:integer month values. year month components xdt:yearMonthDuration correspond Gregorian year month components defined section respectively. xdt:dayTimeDuration derived xs:duration restricting lexical representation contain only days, hours, minutes seconds components. value space xdt:dayTimeDuration set fractional second values. components xdt:dayTimeDuration correspond day, hour, minute second components defined Section respectively. new datatypes are suitable use RDF OWL. are not yet recommended, since F&O still Working Draft). Use Numeric Types much data Semantic Web motivation providing type information permit use data engineering applications, interoperation engineering applications. Most such data be marked up using numeric types XML Schema. Loss precision unexpected changes values due automatic type conversion be problematic engineering environment. engineering domain there are important types usage numerics: count, measurement, constant. count count integer representing essentially cardinal number set things classified set tests. example be count packages candy available shipment. count exact number. Tests include measurements, count not approximation sum measurements sum approximation measurements. type such as xsd:integer type derived xsd:integer appropriate counts. measurement measurement inexact numeric value represented as real) produced measurement method. value value range actual value. actual value unknowable, more precise measurement methods reduce range uncertainty. precision uncertainty usually included measurement value. implicitly using significant figures explicitly using separate property value such as error range. xsd:float xsd:double datatypes are appropriate measurement, be noted do not include precision uncertainity, be included as value separate property. SCHEMA2] explicitly states xsd:decimal not reflected value space, number not distinct number constant constant exact value used computation. not be possible express exactly as numeric. millimeter exactly meters, Pi not Often xsd:decimal be more appropriate xsd:float xsd:double expressing constant. Example 5A example measurement error range indicate weight interval eg:JeremyCarroll eg:weight eg:units eg:value eg:errorRange different usages suggest potential needs concerns type system underlying value spaces types are different, measurements are disjoint counts constants. means capturing precision error/uncertainty needed measurement values. means desirable writing down constants be expressed precisely numeric form. first issues generally be reflected use xsd:integer counts, xsd:float xsd:double measurements, xsd:decimal constants. second issue concerning precision measurements, be addressed modelling level using objects state precision error properties measurements. not bad approach, case, since there are often other properties metadata associated measurement. third issue, concerning constants, solution offered. Acknowledgements Evan Wallace author Section Evan Wallace, Ashok Malhotra, Pat Hayes, Dave Peterson, Dave Reynolds, Michael Sperberg-McQueen Ralph Swick contributed useful reviews. References RDF Semantics, Patrick Hayes, Editor, W3C Recommendation, February Latest version available Primer] RDF Primer, Frank Manola Eric Miller, Editors, W3C Recommendation, February Latest version available Concepts] Resource Description Framework Concepts Abstract Syntax, Graham Klyne Jeremy J. Carroll, Editors, W3C Recommendation, February Latest version available Syntax] RDF/XML Syntax Specification Dave Beckett, Editor, W3C Recommendation, February Latest version available RDF Test Cases, Jan Grant Dave Beckett, Editors, W3C Recommendation, February Latest version available Abstract Syntax] Semantics] OWL Web Ontology Language Semantics Abstract Syntax, Peter F. Patel-Schneider, Patrick Hayes, Ian Horrocks, Editors, W3C Recommendation February Latest version available Guide] OWL Web Ontology Language Guide, Michael K. Smith, Chris Welty, Deborah L. McGuinness, Editors, W3C Recommendation, February Latest version available Test Cases] OWL Web Ontology Language Test Cases Jeremy J. Carroll Jos De Roo, Editors. W3C Recommendation, February Latest version available Framework] XPointer Framework Paul Grosso, Eve Maler, Jonathan Marsh Norman Walsh, Editors, W3C Recommendation, March Latest version available XML Schema Part Structures, Second Edition, W3C Recommendation, World Wide Web Consortium, Henry S. Thompson, David Beech, Murray Maloney Noah Mendelsohn October version latest version available XML Schema Part Datatypes, Second Edition, W3C Recommendation, World Wide Web Consortium, Paul V. Biron Ashok Malhotra October version latest version available N. Freed N. Borenstein. RFC Multipurpose Internet Mail Extensions Part Format Internet Message Bodies. Available T. Berners-Lee, R. Fielding, L. Masinter. Uniform Resource Identifiers Generic Syntax. IETF RFC H. Alvestrand, ed. RFC Tags Identification Languages Available ISO Organization Standardization). Representations dates times, Available ISO Organization Standardization). Language-independent Datatypes. Available Unicode Standard, Version Unicode Consortium, Addison-Wesley, ISBN as updated time time publication new versions. latest version additional information versions standard Unicode Character Database). Operators] XQuery XPath Functions Operators, Ashok Malhotra, Jim Melton Norman Walsh World Wide Web Consortium Working Draft, work progress, September version Functions Operators latest version Functions Operators XML Path Language Anders Berglund, Scott Boag, Don Chamberlin, Mary F. Fernández, Michael Kay, Jonathan Robie Jérôme Siméon W3C Candidate Recommendation November version XML Path Language latest version XML Path Language SPARQL Query Language RDF, Eric Prud'hommeaux Andy Seaborne, Editors, W3C Working Draft July Latest version available XML Schema Component Designators, Mary Holstege Asir S. Vedamuthu, Editors, W3C Working Draft, March Latest version available Description Logics: Reasoning Support Semantic Web, Jeff Z.Pan, PhD Thesis, School Computer Science, University Manchester, OWL-Eu: Adding Customised Datatypes OWL, Jeff Z.Pan Ian Horrocks. Proc. Second European Semantic Web Conference pages extended version Journal Web Semantic, online version available Primer: Getting RDF Semantic Web using N3 Tim Berners-Lee, Dan Connolly Appendix Semantics Datatyping Semantic Web Recommendations A.1 Datatypes RDF According Semantics], section RDF use datatypes defined external type systems, e.g., XML Schema type system, conform following specification. RDF, datatype d characterised value space, V(d), non-empty set, lexical space, L(d), non-empty set Unicode strings, total mapping L2V(d) lexical space value space. specification use non-list XML Schema simple types as datatypes RDF. literals have lexical form being Unicode string. Typed literals are form Unicode string, called lexical form typed literal, URI reference datatype. Plain literals have lexical form optionally language tag as defined normalized lowercase. Example Boolean datatype value space lexical space lexical-to-value mapping typed literal, plain literal. associations datatype URI references xsd:boolean) datatypes boolean) be provided datatype maps defined as datatype map D partial mapping datatype URI references datatypes. RDFS-interpretation w.r.t. datatype map D be defined as Given datatype map D, RDFS D-interpretation vocabulary V RDFS-interpretation V∪{u distinguished subset LV IR, called set literal values, plain literals V, mapping IL literals V IR, following extra conditions: LV ICEXT(rdfs:Literal). plain literal IL(pl) pl. pair d D(u), ICEXT(rdfs:Datatype), there d∈IR s.t. d, ICEXT(d) V(d) LV, d, then IL("s"^^u') L2S(d)(s); otherwise, IL("s"^^u') IR LV. d ICEXT(rdfs:Datatype), then IEXT(rdfs:subClassOf). A.2 Datatypes OWL DL OWL Full datatyping RDF Semantics as above; OWL DL datatyping specified section Semantics], as fundamental difference RDF datatyping OWL DL datatyping relationship datatypes classes. OWL DL, datatypes are not classes, object datatype domains are disjoint other. OWL different OWL reasoners provide different supported datatypes. Given datatype map D, datatype URI reference called supported datatype URI reference w.r.t. D there datatype d such case, d called supported datatype w.r.t. otherwise, called unsupported datatype URI reference w.r.t. D. OWL use so called enumerated datatypes, are built using literals. Let y1, yn be literals. enumerated datatype form oneOf(y1, yn). OWL DL D-interpretation w.r.t. datatype map D be defined as OWL DL datatype interpretation w.r.t. datatype map D pair datatype domain LV value spaces datatype D PL value space plain literals, i.e., union set Unicode strings set pairs Unicode strings language tags) ED datatype interpretation function, satisfythe following conditions: LV ED(rdfs:Literal). plain literal ED(pl) PL. supported datatype URIref d D(u)): ED(u) V(d) LV, s L(d), then ED("s"^^u) L2V(d)(s);otherwise, ED("s"^^u) not defined. unsupported datatype URIref ED(u) LV andED("s"^^u) ED(u). enumerated datatype oneOf(y1, interpreted as Note here simplify presentation using ED as theinterpretation function datatype URI references andliterals, Semantics]uses EC datatypes URI references L literals. OWL Full, disjointness restriction object datatype domains not required. Appendix B: Integrating Description Logics User-Defined Datatypes present scheme ofintegrating large family decidable Description Logics(including SHOIN, underpinning OWL DL) unarydatatype groups, so as support user defined datatypes. Acombined DL decidable unary datatype group conforming.A conforming unary datatype group equipped decisionprocedure satisfiability problem finite conjunctionsover supported datatypes. unary datatypegroup G triple D datatype map,B set primitive base datatype URI references G domis declared domain function. call S set supporteddatatype URI references, i.e., D(u) defined; werequire B S. declared domain function dom followingproperties: S, B, dom(u) otherwise, dom(u)= v, v B. assume there datatype URIreference rdfsx:DatatypeBottom such D(rdfsx:DatatypeBottom) isundefined. Note datatypegroups allow arbitrary datatype predicates, here consideronly datatypes, be regarded as unary datatypepredicates. Example B G1=(D1,B1,dom1) aunary datatype group, D1 integer, xsd:string→ string, xsd:nonNegativeInteger xsdx:integerLessThanN B1 xsd:string}, dom1 xsd:integer,xsd:string xsd:string, xsd:nonNegativeInteger→ xsd:integer, xsdx:integerLessThanN According D1, have S1 xsd:nonNegativeInteger, xsdx:integerGreaterThanN},hence have B1 S1. Note valuespace isV(<N) V(integer) L2S(integer)(N)} mean there built-indatatype integerL2S(integer)(N). unary datatype group, datatype expressions be used torepresent user defined datatypes. Let G be unarydatatype group, set unary datatype expressions G,abbreviated Dexp(G), inductively defined as let be datatype URI reference, DPexp(G); let be datatype URI reference, negationnot(u) DPexp(G); let y1, yn be literals, theenumerated datatype oneOf(y1, yn) p,q DPexp(G), conjunction p,q DPexp(G), disjunction Example C XML Schema user defined datatype humanAge defined 1A] be represented thefollowing unary datatype expression: datatypeinterpretation unary datatype group G apair datatype domain LV non-empty set andED datatype interpretation function thefollowing conditions: ED(rdfs:Literal)=LV ED(rdfsx:DatatypeBottom)} plain literal ED(pl) PL PL LV. primitivebase datatype URI references u1 u2,ED(u1) ED(u2) supported datatype URI reference S d D(u)): ED(u) V(d) V(D(dom(u))) LV, L(D(u)) L(D(dom(u)) andL2S(D(u)) L2S(D(dom(u)), s L(d), then ED("s"^^u) L2V(d)(s);otherwise, ED("s"^^u) not defined. unsupported datatype URI reference S, ED(u) LVand ED(u). datatype interpretation function ED be extended providesemantics unary datatype expressions as Relativised negations: S D, ED(not(u)) ED(dom(U)) otherwise, ED(not(u)) LV ED(u). Enumerated datatypes: ED(oneOf(y1, Conjunctions: ED(and(p,q)) ED(p) ED(q). Disjunctions: ED(or(p,q)) ED(p) ED(q). shows combine decidable DL SHOIN, underpinning OWL DL) conjunction bottom constructors conforming unary datatype group combined DL still decidable. Appendix C: Changes since Working Draft April C.1 Typos etc. introduction. Updated syntax XML Schema Component Designators. Deleted broken link description Added reference ISO homepage instead. C.2 Discussion removal earlier draft was discussion document. note not intended as such, so issues, particularly do interactions various standards, recommendations, RFCs etc. been removed. Removed DAML+OIL solution. Removed true values solution. Removed XPath eq solution. Moved OWL syntax example DAML+OIL section end id section. XML Schema Component Designator section: Discussion relationship XSCD, XPointer RFC been removed. Discussion about exact semantics XSCD fragment been removed. Deleted words contentious)" id solution. Changed XML Schema Component Designator section, indicate XSCD good practice. particular, last paragraph. Changed discussion subsection user defined datatypes suggest solutions are appropriate, have discussion. Changed title Suggested Practice. Discussion harder examples cut down substantially, since are trivially non-entailments agreed semantics. Removed EDITORS' OPINION notes. C.3 Changes response comment Ashok Malhotra Deleted uses word section since caused confusion. Added links XML Schema document union, list restriction, make clear intended concept as defined document. Added brief discussion target namespace after example 2A providing further examples example 2B example 2C. Scoped document not address Schema assembled multiple schema documents". Added reference SCHEMA1]. XML Schema Component Designator section: added more extended discussion target namespace issue; added example XSCD schema target namespace. Added text showing @id solution comply secondary resource concept RFC read conjunction RDF Concepts, XPointer XML Schema. C.4 Restructuring section Reordered subsections section deleting old ordering remaining subsections as Followed renumbering. Text discussing examples changed, change tracking not detailed. Moved definition primitive base datatype examples subsection formal analysis subsection. Deleted references examples new section Added example SPARQL query, show use SPARQL compare type hierarchy. Added updated discussion mapsTo. C.5 Other changes Added further acknowledgements. Updated reference RFC be RFC Updated Table Contents Removed unused references. Updated versions W3C WD's references. 